// vim: tw=72 et ts=2 sts=2 sw=2:

"use strict";

// Given an expression (an array of numbers and operators), and an
// expected value (a number), return an array containing the different
// ways, if any exist, of bracketing the expression in order to produce
// the expected value.
function paren_expr(expr, expected_value) {

  function dbg(msg) {
    // console.log(msg);
  }

  // Functions that evaluate the operators that are supported by the
  // expression language.
  var ops = {
    '+': function(a, b) { return a + b; },
    '-': function(a, b) { return a - b; },
    '*': function(a, b) { return a * b; },
    '/': function(a, b) { return a / b; }
  }

  // Verify that this expression is valid. It should consist of numbers
  // alternating with operators.
  function validate(expr) {
    function checkNum(i) {
      if (isNaN(parseFloat(expr[i]))) {
        throw ('Term at [' + i + '] is not a number: "' + expr[i] + '"');
      }
    }
    for (var i=1; i < expr.length; i += 2) {
      checkNum(i-1);
      if (!ops[expr[i]]) {
        throw ('Element at [' + i + '] is not an operator.');
      }
    }
    checkNum(expr.length - 1);
  }

  // Return a string representation of the expression.
  function str(expr) {
    if (expr.constructor === Array) {
      if (expr.length === 1 && expr[0].constructor !== Array) {
        return expr[0];
      } else {
        return '(' + expr.map(str).join('') + ')';
      }
    } else {
      return expr;
    }
  }

  // This function generates all the possible parenthesized groupings of
  // this expression.
  function group(expr) {
    dbg('Parsing group:');
    dbg(expr);
    // If the expression is down to a single term, just return the
    // expression containing that term.
    if (expr.length == 1) {
      dbg('Reached bottom: ' + expr[0]);
      return expr;
    }
    // Generate the different possible groupings of this list of terms.
    var grouping_options = [];
    for (var i=1; i < expr.length; i += 2) {
      var operator = expr[i];
      var before = expr.slice(0, i);
      var after = expr.slice(i+1);
      dbg('operator: ' + operator);
      dbg('before:');
      dbg(before);
      dbg('after:');
      dbg(after);
      var beforeGroups = group(before);
      var afterGroups = group(after);
      for (var b=0; b < beforeGroups.length; b++) {
        for (var a=0; a < afterGroups.length; a++) {
          grouping_options.push(
              [beforeGroups[b], operator, afterGroups[a]]);
        }
      }
    }
    dbg('return:');
    dbg(grouping_options.map(str));
    return grouping_options;
  }

  // Evaluate an expression generated by the grouping function.
  function evaluate(expr) {
    if (expr.constructor === Number) {
      // If this expression is just a number, return that number.
      return expr;
    } else {
      // If this is a binary operator expression, look up the function
      // that evaluates that operator and apply it to the operands.
      var operator_function = ops[expr[1]];
      var a = evaluate(expr[0]);
      var b = evaluate(expr[2]);
      return operator_function(a, b);
    }
  }

  validate(expr);

  var groupings = group(expr);
  var matches = [];
  dbg('-------------------------------');
  dbg('Evaluating.');
  for (var g in groupings) {
    dbg(str(groupings[g]));
    var v = evaluate(groupings[g]);
    if (v === expected_value) {
      matches.push(groupings[g]);      
    }
    dbg(' -> ' + v);
  }
  dbg('Done evaluating.');
  dbg('-------------------------------');

  return matches.map(str);
}

console.log(paren_expr([4, '*', 5, '+', 7, '*', 8], (4*(5+7)*8)));
console.log(paren_expr([9, '/', 5, '+', 2, '*', 7], (9/(5+2)*7)));

